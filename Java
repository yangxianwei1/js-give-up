一：
java当中的class就大似相当于c语言中的struct
但是c语言当中的struct只包含静态的属性（变量），而java当中class还可以包含动态的操作（方法）
二：
java当中的new就相当于c语言中的malloc函数，不过比malloc函数好，不需要自己手动释放 而是由jvm释放
三：(DOS环境下)
java源代码文件类型扩展名为.java -> 通过javac编译之后生成名为.class的字节码文件 -> 然后在通过java+该文件名来运行（可省略.class）
四：
语法基础：数据类型{1.基本数据类型和2.引用数据类型}，其中1又包括数值型 字符型 和布尔型Boolean ，2又包括类、接口和数组
剩余省略
五：面向对象
（啥是类）①类：把一类事物的静态属性和动态可以执行的操作组合在一起所得到的这个概念就是类
②类是抽象的，用来模拟一类事物，是一个概念
③一旦被定义，类的概念就永远存在了
（啥是对象）
类的一个个体、具体的 实实在在存在的事物、生命周期是短暂的，会生成和消亡。
对象是汽车的话那么类就是汽车设计图
eg类
/*  class Person
{
int age;
int weight;
}
Person yxw=new Person();//new Person()是在堆中动态分配一块区域 被当作了A对象来使用
而yxw（静态分配）是在栈中分配的 堆中内存的地址赋给了yxw yxw指向了堆中的内存 yxw代表了堆中的内存
*/
内存分配：
内存中->heap、stack、data segment、code segment
一般在java中 new出来的东西存放在堆（heap）里面 局部变量存放在stack里面  静态变量和字符串变量存放在data segment中 代码存放在code segment中
凡是在堆里面的东西都需要我们手动释放（c、c++感觉明显 java是由虚拟机来释放） 在栈里面的是由系统来释放的 
访问控制符：
（通常在java的对象中 我们一般将其静态的属性设置为私有的 然后在设置一个公有的方法 通过共有的方法来改变私有的变量 只对外部提供方法而不提供类的私有属性 这样
就会变得更加安全）
类的构造函数：（有参数、无参数）
该函数没有返回类型 不像我们普通的函数有int 、void ..，在一个类中 （利用该类生成一个对象时）如果有无参构造函数无论是否调用 都会自动执行
/*
class a
{
private int i;
public a(){
system.out.printf("无参函数被调用");
}
}
class testA
{
public static void main(String[]args)
{
a a2=new a();//只要执行这一步 就会显示该函数被调用
}
}
/***************************/

class a
{
private int i;
public a(int j){
i=j;
system.out.printf("无参函数被调用");
}
}
class testA
{
public static void main(String[]args)
{
a a2=new a(2);//当我们构造出a2对象时 会将2赋值给a类中的i值  也就是说在定义该对象的同时完成对该事物的初始化

}
}
*/
函数的重载：（同名的函数通过不同的形参做类似的事情）
在c++和java中可以 就是函数名字相同但是形参个数不同
函数重载要求：1.函数的形参个数2.函数的形参顺序3.函数的形参数据类型 这三个至少有一个时不一样的
总结一下上面的：在java每个类里都至少有一个构造方法，如果程序员没有在该类里面定义构造函数（方法）那么该类会默认生成一个默认的构造方法 该方法没有参数
也不会在程序中体现 即啥也不做 一般不能满足我们的要求 所以我们可以自己定义类的构造方法 定义完之后就覆盖了以前的（无参、形参都可以共同存在）
  还有一个小知识点：
  在一个类中 可以不初始化一个变量 此时该变量的值时默认（数据值为1 Boolean值为false）在构造函数中修改此变量会使修改后的值，
  但是在一个对象函数中 不初始化则不能使用
    this：---->指向当前正在调用该方法的对象
    （在java中 new出来的对象时保存在heap堆中的 两个对象其实时共用一个类中的方法的 方法保存在内存中的代码区域 但是怎样识别时当前对象调用
    的该方法呢 所以引出了this 设计上就时将当前对象的地址传给了该类中的方法 因为方法是共用的 所以通过地址也就是this就知道是哪个对象了）
   是一个系统隐藏的指针被自动附加在非静态的成员函数参数列表中
   当前时刻，哪个对象调用该函数，那么this就指向当前调用该函数的对象，系统会自动在该函数的参数列表中添加一个隐藏的this指针，并且把
   调用该函的的对象的地址赋给this指针，这样一来在函数的内部通过this就可以访问当前正在调用该函数的对象的成员，注意：静态函数内部没有this指针
    
    
    如果是在普通方法中应用this  那么this指向的是当前调用该方法中的对象
    如果是在构造函数中应用this 那么this代表的是当前时刻正在创建的对象 也就是本身  记住  this所在的先后位置不一样 看截图
     
     static：（多个对象共用这static所定义的属性）->如果想通过类名访问该属性就必须定义为static类型 否则只能通过对象来访问
     
     在内存中有一块data segment 用来存储字符串和静态变量 其中 static就是静态变量就是存储在该区域
     进一步讲static所定义的属性是属于类本身的 或者讲没有类构造的对象我们仍然可以通过该类名来访问该类内部的static属性
     static也可以应用于方法（函数），但是static属性和方法很明显也属于对象，当然也可以通过类对象名（类目.）的方式来访问
     总的->static是属于类本身的是可以通过类名本身来访问的但是必须是非私有的，或者是说static只是表明了该成员具有了可以通过类名访问的潜在特征，但是否
     可以通过类名访问必须还是非私有的
     在一个类中 非静态的可以访问静态的 但是静态的方法不可以访问非静态的变量和方法 （想想  要是像访问一个类中的非静态属性和方法是不是必须要
     构造一个对象，so才不会访问）
    static所定义的方法没有this   
    
    
    
    
    
    
    
    
    
    
    
    


