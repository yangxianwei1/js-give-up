一：
java当中的class就大似相当于c语言中的struct
但是c语言当中的struct只包含静态的属性（变量），而java当中class还可以包含动态的操作（方法）
二：
java当中的new就相当于c语言中的malloc函数，不过比malloc函数好，不需要自己手动释放 而是由jvm释放
三：(DOS环境下)
java源代码文件类型扩展名为.java -> 通过javac编译之后生成名为.class的字节码文件 -> 然后在通过java+该文件名来运行（可省略.class）
四：
语法基础：数据类型{1.基本数据类型和2.引用数据类型}，其中1又包括数值型 字符型 和布尔型Boolean ，2又包括类、接口和数组
剩余省略
五：面向对象
（啥是类）①类：把一类事物的静态属性和动态可以执行的操作组合在一起所得到的这个概念就是类
②类是抽象的，用来模拟一类事物，是一个概念
③一旦被定义，类的概念就永远存在了
（啥是对象）
类的一个个体、具体的 实实在在存在的事物、生命周期是短暂的，会生成和消亡。
对象是汽车的话那么类就是汽车设计图
eg类
/*  class Person
{
int age;
int weight;
}
Person yxw=new Person();//new Person()是在堆中动态分配一块区域 被当作了A对象来使用
而yxw（静态分配）是在栈中分配的 堆中内存的地址赋给了yxw yxw指向了堆中的内存 yxw代表了堆中的内存
*/
内存分配：
内存中->heap、stack、data segment、code segment
一般在java中 new出来的东西存放在堆（heap）里面 局部变量存放在stack里面  静态变量和字符串变量存放在data segment中 代码存放在code segment中
凡是在堆里面的东西都需要我们手动释放（c、c++感觉明显 java是由虚拟机来释放） 在栈里面的是由系统来释放的 
访问控制符：
（通常在java的对象中 我们一般将其静态的属性设置为私有的 然后在设置一个公有的方法 通过共有的方法来改变私有的变量 只对外部提供方法而不提供类的私有属性 这样
就会变得更加安全）
类的构造函数：（有参数、无参数）
该函数没有返回类型 不像我们普通的函数有int 、void ..，在一个类中 （利用该类生成一个对象时）如果有无参构造函数无论是否调用 都会自动执行
/*
class a
{
private int i;
public a(){
system.out.printf("无参函数被调用");
}
}
class testA
{
public static void main(String[]args)
{
a a2=new a();//只要执行这一步 就会显示该函数被调用
}
}
/***************************/

class a
{
private int i;
public a(int j){
i=j;
system.out.printf("无参函数被调用");
}
}
class testA
{
public static void main(String[]args)
{
a a2=new a(2);//当我们构造出a2对象时 会将2赋值给a类中的i值  也就是说在定义该对象的同时完成对该事物的初始化

}
}
*/
函数的重载：（同名的函数通过不同的形参做类似的事情）
在c++和java中可以 就是函数名字相同但是形参个数不同
函数重载要求：1.函数的形参个数2.函数的形参顺序3.函数的形参数据类型 这三个至少有一个时不一样的
总结一下上面的：在java每个类里都至少有一个构造方法，如果程序员没有在该类里面定义构造函数（方法）那么该类会默认生成一个默认的构造方法 该方法没有参数
也不会在程序中体现 即啥也不做 一般不能满足我们的要求 所以我们可以自己定义类的构造方法 定义完之后就覆盖了以前的（无参、形参都可以共同存在）
  还有一个小知识点：
  在一个类中 可以不初始化一个变量 此时该变量的值时默认（数据值为1 Boolean值为false）在构造函数中修改此变量会使修改后的值，
  但是在一个对象函数中 不初始化则不能使用
    this：---->指向当前正在调用该方法的对象
    （在java中 new出来的对象时保存在heap堆中的 两个对象其实时共用一个类中的方法的 方法保存在内存中的代码区域 但是怎样识别时当前对象调用
    的该方法呢 所以引出了this 设计上就时将当前对象的地址传给了该类中的方法 因为方法是共用的 所以通过地址也就是this就知道是哪个对象了）
   是一个系统隐藏的指针被自动附加在非静态的成员函数参数列表中
   当前时刻，哪个对象调用该函数，那么this就指向当前调用该函数的对象，系统会自动在该函数的参数列表中添加一个隐藏的this指针，并且把
   调用该函的的对象的地址赋给this指针，这样一来在函数的内部通过this就可以访问当前正在调用该函数的对象的成员，注意：静态函数内部没有this指针
    
    
    如果是在普通方法中应用this  那么this指向的是当前调用该方法中的对象
    如果是在构造函数中应用this 那么this代表的是当前时刻正在创建的对象 也就是本身  记住  this所在的先后位置不一样 看截图
     
     static：（多个对象共用这static所定义的属性）->如果想通过类名访问该属性就必须定义为static类型 否则只能通过对象来访问
     
     在内存中有一块data segment 用来存储字符串和静态变量 其中 static就是静态变量就是存储在该区域
     进一步讲static所定义的属性是属于类本身的 或者讲没有类构造的对象我们仍然可以通过该类名来访问该类内部的static属性
     static也可以应用于方法（函数），但是static属性和方法很明显也属于对象，当然也可以通过类对象名（类目.）的方式来访问
     总的->static是属于类本身的是可以通过类名本身来访问的但是必须是非私有的，或者是说static只是表明了该成员具有了可以通过类名访问的潜在特征，但是否
     可以通过类名访问必须还是非私有的
     在一个类中 非静态的可以访问静态的 但是静态的方法不可以访问非静态的变量和方法 （想想  要是像访问一个类中的非静态属性和方法是不是必须要
     构造一个对象，so才不会访问）
    static所定义的方法没有this   
             在一个类中也可以构造一个对象当作是aa的一个属性（也就是一个事物包含另一个事物）
          继承：
    一个新类从已有的类那里获得其已有的属性和方法，这种现象叫做继承，然后这个心累被称为子类，已有的哪个类叫做父类也叫做基类。
    继承的好处——>①代码得到极大的重用 ②形成一种类的层次体系结构，为多态创造条件。③可以更好的模拟出世界事物之间的联系
    继承eg. class SubClass extends SuperClass
    {
    //son叫做子类或者叫做派生类
    farther叫做父类也叫做基类
    //另外 父类私有的方法和属性不能被子类继承和访问   
    //通过子类对象名只能访问从父类继承过来的非私有成员
    //也就是说私有不能被继承（或者是说从物理上讲私有的已经被继承过来了 只不过我们不能访问它，所以说继承一定要慎重 否则会浪费空间）
    
    //包（不同的类有不同的用途  将这些类放在一个包里便于统一管理）
    //可以大致的把包看作一个文件夹 里面存放着类
    
    //访问不同包没有任何关系的类的话只能是public 才能访问   别的都不可以
    
    //不同包的继承只能继承public和protected的类
    }
    java只支持单继承，不(c++)允许多重继承
    （
    单继承->就是一个类只能有一个父亲
    多继承->就是一个类可以有多个父亲
    
    ）
    子类可以继承父类所有的成员变量和成员方法(非私有)，但是子类永远
    无法继承父类的构造方法，如果想要继承可以在子类的构造方法中使用
    语句super(参数列表)调用父类的构造方法
    在调用该构造方法时要注意：
    ①每个子类构造方法的第一条语句都是在隐含的调用super(),如果父类没有无参的构造函数（有有参的）那么编译器此时就会报错。
    ②写super之前要看要和父类有参还是无参构造函数相统一 
    ③super必须在开头的第一条语句
    ④调用父类的构造函数必须用super而不能直接写父类的类名
    
    
          方法重写(也不能说是重写 )——>在子类中重新定义（再次设计一个）父类的方法(利用super.加方法名());
          必须继承的时候才能重写 而且重写的要求必须是和父类中要重写的方法相同名字相同参数 相同返回值 ，否则的话就会报错 （两个函数不知都用哪一个）
          
          
       什么叫做多态》->其实就是把子类的引用发送给父类  让父类根据当前时刻的指向自动调用相应的方法
    概念：一个父类的引用类型变量它既可以指向父类对象也可以指向子类对象，它可以根据当前时刻指向的不同自动调用不同对象的方法 这就是多态
    利用多态可以实现同一段代码做不同的事情（通过引用父类可以指向子类的对象eg farther =son 将子类付给父类 也就是父类指向了子类 但是父类指向他后只能调用 
    它所继承父类的方法 不可以调用子类所特头的方法  这是多态的另一个特点。
        
        抽象类  ->用abstract关键字来修饰一个类时，该类叫做抽象类
        抽象类通常用来作为一个类族的最顶层的父亲，用最底层的类表示现实当中的具体事物，用最顶层的类表示该类族所有事物的共性。
        抽象方法 (没有方法体的方法叫做抽象方法 抽象方法要求名字()后面必须右分号 前面必须有abstract修饰 )->只给出方法头 而不给出具体方法
    、   另外 含有抽象方法的类必须是抽象类
       我们可以定义抽象类的引用，但是不可以定义抽象类的对象。引用就相当与一个指针 指向子类 然后通过多态就可以调用子类所继承抽象类来实现具体的方法
    
          final:可以修饰整个类 并且表示该类不可以被继承，如果认为一个类不需要在定义一个子类来继承他那么就可以使用final
          final修饰一个类的属性时 必须要对该属性赋值 并且不会再改变了 相当于C语言中的const
          
          
              接口：
              接口的定义：是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类 
               接口的格式和类差不多 将class改为interface，另外 一个接口可以继承多个接口，类只能继承一个父类
               注意①：接口定义的属性必须是public static final的，而接口定义的方法则必须是public abstract的，
               因此这些修饰符可以部分或全部省略
               ②：接口中定义的属性值在实现类中不能被修改
               ③：一个类之只能实现某个接口，不能继承某个接口
               但是接口可以继承接口
               ④：接口不但可以继承接口，而且可以继承多个接口，即接口允许多继承
               ⑤：如果一个类值实现了一个接口的部分方法，则该类必须声明为抽象类
               ⑥：一个类可以在继承一个父类的同时实现一个或多个接口，但是extends关键字
               必须要在implements之前
               器：不可以new接口对象，但可以定义一个接口引用类型的变量并将其指向实现接口的对象，达到多态的目的
               
               package：package语句必须是第一条语句 在package包下面建立的类 编译之后其类名都将会变成包名和类名的组合

在同一个包中只有私有的不能被另一个类访问,特只有私有的不能被继承
在不同包没有任何关系的两个类，只有public类的public成员才可以被另一个类访问
在不同包中右继承关系的两个类，只有public类的public成员和public类的protect二点成员可以被另一个包中的子类在内部使用，但是在子类的外部，通过子类对象名只能访问父类的public成员。
               
